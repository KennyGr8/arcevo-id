import fs from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";

// ğŸ‘‡ Fix __dirname in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// âœ… Prisma schema header
const schemaHeader = `
generator client {
  provider = "prisma-client-js"
  output   = "../auth-kit-core/src/@generated"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator seed {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}

// This file is auto-generated by the build-schema script.
// Do not edit directly. Modify files in prisma/schemas instead.
`.trim();

export async function buildSchema() {
  const schemasDir = path.resolve(__dirname, "../prisma/schemas");
  const output = path.resolve(__dirname, "../prisma/schema.prisma");

  const files = await fs.readdir(schemasDir);

  const parts = await Promise.all(
    files
      .filter((f) => f.endsWith(".prisma"))
      .sort() // Optional: sort alphabetically for consistency
      .map(async (f) => {
        const content = await fs.readFile(path.join(schemasDir, f), "utf-8");
        // Strip out any accidental datasource/generator blocks
        return content
          .replace(/generator\s+\w+\s+\{[^}]*\}/g, "")
          .replace(/datasource\s+\w+\s+\{[^}]*\}/g, "")
          .trim();
      })
  );

  const finalSchema = [schemaHeader, ...parts].join("\n\n");
  await fs.writeFile(output, finalSchema);

  console.log(`âœ… schema.prisma generated at ${output}`);
}

// âœ… ESM-compatible CLI entry
if (import.meta.url === `file://${process.argv[1]}` || import.meta.url === process.argv[1]) {
  buildSchema().catch((err) => {
    console.error("âŒ Failed to generate schema.prisma:", err instanceof Error ? err.message : err);
    process.exit(1);
  });
}
